% type
\documentclass{article}

% format
\usepackage[letterpaper, margin=1.5cm]{geometry}
\usepackage[utf8]{inputenc}
% font
\renewcommand{\familydefault}{\sfdefault}
\usepackage[dvipsnames]{xcolor}
\usepackage{sectsty}
\allsectionsfont{\color{DarkOrchid}}

% language
\usepackage[spanish]{babel}

% math symbols
\usepackage{amssymb}

% macros
\newcommand{\tx}[1]{\texttt{#1}}

% code
\usepackage{minted}

% header

\title {
    Práctica 6\\
    Excepciones y Continuaciones en la Máquina $\mathcal{K}$
}

\author {
    Sandra del Mar Soto Corderi \quad Edgar Quiroz Castañeda
}

% document
\begin{document}
    \maketitle

    \section{La Maquina $\mathcal{K}$}

    \subsection{Marcos}

    Para modelar la máquina abstracta $\mathcal{K}$, en necesario tener una 
    estrucutra que guarde los cómputos pendientes, llamados marcos. Hay un marco
    por cada posible cómputo pendiente de algún operador.

    \begin{minted}{haskell}
    -- | Tipo de marcos vacíos
    type Pending = ()

    -- | Tipo de marco
    data Frame = SuccF Pending
               | PredF Pending
               | ...
               | RaiseF Pending
               | HandleF Pending Identifier Expr
               | ContinueFL Pending Expr
               | ContinueFR Expr Pending
               deriving (Eq)
    \end{minted}

    \begin{itemize}
        \item \tx{instance Show Frame}

        Sólo se tomó un el inicio del nombre del operador correspondiente, 
        remplazando el cómputo pendiente con un guión \tx{-}.

        \begin{minted}{haskell}
        -- | Show para marcos
        instance Show Frame where
            show ex =
            case ex of
                (SuccF _) -> "suc(-)"
                (PredF _) -> "pred(-)"
                ...
                (RaiseF _) -> "raise(-)"
                (HandleF _, x, e2) -> "handle(-, " ++ (show x) ++ ", " ++ (show e2) ++ ")"
                (ContinueFL _ e) -> "continue(-, " ++ (show e) ++ ")"
                (ContinueFR e _) -> "continue(" ++ (show e) ++ ", -)"
        \end{minted}
    \end{itemize}

    \subsection{Estados}

    Ahora que hay que tener un registro de los cómputos pendientes, los estados
    al momento de evaluar expresiones cambian.

    Hay tres posibles estados: evaluando, terminando, y error.

    \begin{minted}{haskell}
        -- | Tipo para estados
        data State = E (Memory, Stack, Expr) | R (Memory, Stack, Expr) 
              | P (Memory, Stack, Expr)
    \end{minted}

    \begin{itemize}
        \item \tx{instance Show State}

        En los ejemplos en la descripción de la práctica, los estados se
        mostraban directamente como están definidos.

        Así que para mantener este formato de manera sencilla, sólo se agregó 
        que los estados derivaran su instancia de \tx{Show} de su definición.

        \begin{minted}{haskell}
            -- | Tipo para estados
            data State = E (Memory, Stack, Expr) | R (Memory, Stack, Expr) 
              | P (Memory, Stack, Expr)
              deriving (Show)
        \end{minted}



    \end{itemize}

    \section{Excepciones y Continuaciones}

    \begin{itemize}
        \item \tx{eval1}
        \item\tx{evals}
        \item \tx{eval}
    \end{itemize}

    \section{Integración}

    \begin{itemize}
        \item \tx{frVars}
        \begin{minted}{haskell}
-- | Obteniendo variables libres de una expresion(AddFL _ e) -> "add(-, " ++ (show e) ++ ")"
frVars :: Expr -> [Identifier]
frVars ex =
	case ex of
		...
		(Void) -> []
		(Seq e f) -> union (frVars e) (frVars f)
		(While e f) -> union (frVars e) (frVars f)
		(Raise e) -> frVars e
		(Handle e i f) -> union (frVars e) ((frVars f) \\ [i])
		(LetCC i e) -> (frVars e) \\ [i]
		(Continue e f) -> union (frVars e) (frVars f)
		(Cont s) -> []
        \end{minted}
        
        
        \item \tx{subst}
        \begin{minted}{haskell}
    -- | Aplicando substitucion si es semanticamente posible
subst :: Expr -> Substitution -> Expr
subst ex s@(y, e') =
	case ex of
		...
		(Seq e f) -> Seq (st e) (st f)
		(While e f) -> While (st e) (st f)
		(Raise e) -> Raise (st e)
		(Handle e x f) ->
			if x == y || elem x (frVars e')
				then st (alphaExpr ex)
			else Handle e x (st f)
		(LetCC x e) ->
			if x == y || elem x (frVars e')
				then st (alphaExpr ex)
			else LetCC x (st e)
		(Continue e f) -> Continue (st e) (st f)
		(Cont a) -> Cont a
		where st = (flip subst) s
        \end{minted}
        
        \item \tx{alphaEq}
        \begin{minted}{haskell}
-- | Dice si dos expresiones son alpha equivalentes
alphaEq :: Expr -> Expr -> Bool
...
alphaEq (Seq e1 e2) (Seq f1 f2) = (alphaEq e1 f1) && (alphaEq e2 f2)
alphaEq (While e1 e2) (While f1 f2) = (alphaEq e1 f1) && (alphaEq e2 f2)
alphaEq (Raise e) (Raise f) = alphaEq e f
alphaEq (Handle e1 x e2) (Handle f1 y f2) = (alphaEq e1 f1) && (alphaEq e2 (subst f2 (y, (V x))))
alphaEq (LetCC x e) (LetCC y f) = (alphaEq e (subst f (y, (V x))))
alphaEq (Continue e1 e2) (Continue f1 f2) = (alphaEq e1 f1) && (alphaEq e2 f2)
alphaEq (Cont s1) (Cont s2) = s1 == s2
alphaEq _ _ = False
        \end{minted}
    \end{itemize}

    \section*{Dificultades}
    Nos fue difícil la implementación del eval1 ya que algunas definiciones nos causaban confusión y la longitud del código era bastante larga, por lo que era fácil que hubieran errores en el código.Igual fue complicado manejar los casos que manipulaban las continuaciones y la memoria a la vez.
    
\end{document}


